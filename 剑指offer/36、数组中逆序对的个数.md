
##### [参考](https://juejin.im/post/5b6cfb746fb9a04fae213694)

#### [参考](https://www.jianshu.com/p/c7f98f5cc918)

# 数组中逆序对的个数

## 题目
在数组中的两个数字如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。
输入一个数组，求出这个数组中的逆序对的总数。

## 举例分析
　　例如在数组｛7, 5, 6, 4 }中， 一共存在5 个逆序对，分别是（7, 6）、（7，5），(7, 4）、（6, 4）和（5, 4）。

## 解题思路

### 第一种：：暴力解法

　　顺序扫描整个数组。每扫描到一个数字的时候，逐个比较该数字和它后面的数字的大小。
如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n 个数字。
由于每个数字都要和O(n）个数字作比较， 因此这个算法的时间复杂度是O(n^2)。

### 第二种：分治思想，采用归并排序的思路来处理

> 归并排序

上述思路在进行比较后，并没有将相关信息留下，其实在比较之后可以进行局部的排序，从而降低比较的次数，降低时间复杂度。
 可通过如下步骤求逆序对个数：先把数组逐步分隔成长度为1的子数组，统计出子数组内部的逆序对个数，
 然后再将相邻两个子数组合并成一个有序数组并统计数组之间的逆序对数目，直至合并成一个大的数组。
 其实，这是二路归并的步骤，只不过在归并的同事要多进行一步统计。因此时间复杂度o(nlogn)，空间复杂度o(n)，
 如果使用原地归并排序，可以将空间复杂度降为o(1)。
 
 本文使用经典二路归并排序实现。以{7,5,6,4}为例，过程如下：
```
 
            [7     5    6    4]                 
             /              \                  分：将长度为4的数组分成长度为2的数组
         [7    5]         [6    4]
         /      \         /      \             分：将长度为2的数组分成长度为1的数组
      [7]       [5]    [6]        [4]
       \         /        \       /            和：1->2，并记录子数组内的逆序对
         [5    7]         [4    6] 
            \                 /                和：2->4，并记录子数组内的逆序对
            [4     5    6    7]
```

[No36_InversePairsCore](/algorithms-java-example/src/main/java/space.mamba/coding/interviews/No36_InversePairsCore.java)
