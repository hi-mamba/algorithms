

# 正则表达式匹配

## 题目描述
请实现一个函数用来匹配包括.和*的正则表达式。模式中的字符.表示任意一个字符，而*表示它前面的字符可以出现任意次（包含0次）。 
在本题中，匹配是指字符串的所有字符匹配整个模式。
例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配。

输入字符串为str，模式为pattern


## 思路

### 解法一
动态规划的思路。只要模式字符串当前为“.”，一定匹配，如果是当前不匹配，就需要看下一个字符串是否为“”来判断。

### 解法二

这题主要还是难在要考虑 * 的问题 如果模式匹配字符的下一个字符是 * : 如果pttern当前字符和str的当前字符匹配，：有以下三种可能情况

pttern当前字符能匹配 str 中的 0 个字符：match(str, pattern+2)
pttern当前字符能匹配 str 中的 1 个字符：match(str+1, pattern+2)
pttern当前字符能匹配 str 中的 多个字符：match(str+1, pattern)
对于 . 的情况比较简单，. 和一个字符匹配 match(str+1, pattern+1) 要注意时刻判断当前要比较的字符的下标是否会数组越界


--- 

首先，对于*来说，它无法单独存在，只能跟在.或者字母之后。所以，我们可以把.*或者a*这样的组合看做是单个的组合字符。
定义：由.或者字母与*组成的组合字符，称之为通配符。

从第0项开头开始依次进行字符匹配，有几种情况？（暂不考虑到字符串结尾）

p[0]是通配符
1.1 p[0] == '.'或者p[0] == s[0]
这说明第0项是可以匹配的。当然，也可以选择不将s[0]和p[0]进行匹配，例如：
字符串s = "a", p = "a*a"，s[0]的a需要匹配p[2]的a，而不是p[0]的a*。
如果s[0]和p[0]匹配上了，那么接下来就让s[1]和p[0]匹配；反之则让s[0]和p[2]匹配。二者都能化成较小子集的问题，符合动态规划的需求。
1.2 否则，s[0]和p[0]匹配不上，那么就让s[0]和p[2]进行匹配。

p[0]是字母
如果s[0] == p[0]，匹配成功，接下来匹配s[1]和p[1]。
反之，匹配失败，返回false；

p[0]是.
匹配成功，接下来配s[1]和p[1]。

总而言之，核心的思想是把大的问题转化为小一点的问题，递推得出最后的答案。


## 实践例子

[No53_Pattern](/algorithms-java-example/src/main/java/space.mamba/coding/interviews/No53_Pattern.java)

 