##### [原文](https://segmentfault.com/a/1190000015720743)

# 求第N个丑数

## 题目描述
　把只包含因子2、3和5的数称作丑数（Ugly Number）。
例如6、8都是丑数，但14不是，因为它包含因子7。 
习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

> 8 被 2 和 4 整除，但是 4 又被 2 整除【因子包含 2】

## 丑数的定义：

所谓丑数，就是不能被2，3，5以外的其他素数整除的数。1，2，3，4，5，6，8，9，10，12，15是最前面的11个丑数。(1不是素数）

## 基本思路

### 暴力解法： 

如果一个数是丑数，那么这个数，如果能被2整除，就一直除以2，如果能被3整除就一直除以3，如果能被5整除，就一直除以5，最后的结果一定是1。
按照这种思路，从数字1开始判断直到第N个丑数出现即可。

### 动态规划：
> 动态规划思想。后面的丑数一定是由前面的丑数乘以2、3或5得到

这种暴力解法存在大量的重复计算，例如：现在分析12是不是丑数，12/2=6，而6我们已经知道是丑数了，
已经不需要向下计算了。因此我们可以记忆化：将丑数记录下来。 

这个题目有重叠子问题，考虑使用动态规划。我们不妨假设DP[n]表示第n个丑数，这个丑数就等于前面几个丑数*2或者*3或者*5的最小值,
并且丑数的位置只会向后移，我们不妨假设三个i j k分别为*2 *3 *5的丑数位置。由此我们可以写出 状态转移方程：

dp[n] = min{dp[i]*2,dp[j]*3,dp[k]*5}

##### 举个栗子
现在已知6个丑数 1 2 3 4 5 6， 求第7个丑数。

可以翻译成：假设dp[i]表示第i个丑数的数值，已知丑数的个数为count=6，
且前6个丑数 dp[1]=1;dp[2]=2;dp[3]=3;dp[4]=4;dp[5]=5;dp[6]=6; 求dp[7]。

则dp[7]可能有三种情况：
```
从i=1开始按顺序求v = dp[i]*2，当v>dp[6]，可以停止，则第4个丑数乘2得到的8可能是第7个丑数。
从i=1开始按顺序求v = dp[i]*3，当v>dp[6]，可以停止，则第3个丑数乘3得到的9可能是第7个丑数。
从i=1开始按顺序求v = dp[i]*5，当v>dp[6]，可以停止，则第3个丑数乘5得到的10可能是第7个丑数。
取三种情况的最小值，得到8，就是第7个丑数，即dp[7] = 8。
```
依此类推，可以求得第8个丑数。

注意，这里有个小优化，按顺序搜索的时候`并不需要每次都从1开始`，只需要从上次搜索的结束点继续搜索就行了。

例如求dp[8]，同样有三种情况：
```
从i=4开始按顺序求v = dp[i]*2，当v>dp[7]，可以停止，则第5个丑数乘2得到的10可能是第8个丑数。
从i=3开始按顺序求v = dp[i]*3，当v>dp[7]，可以停止，则第3个丑数乘3得到的9可能是第8个丑数。
从i=2开始按顺序求v = dp[i]*5，当v>dp[7]，可以停止，则第2个丑数乘5得到的10可能是第8个丑数。
取三种情况的最小值，得到10，即dp[8] = 9。
```

### 实践例子

[No34_UglyNumber](/algorithms-java-example/src/main/java/space.mamba/coding/interviews/No34_UglyNumber.java)
