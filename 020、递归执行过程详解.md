
## [原文](https://www.cnblogs.com/alex3714/articles/8955091.html)

## [视频](https://www.coursera.org/lecture/c-chengxu-sheji/di-gui-diao-yong-de-guo-cheng-3JLR6)

# 递归执行过程详解

## 什么是递归？
　　递归，就是函数在运行的过程中调用自己。

代码示例

```python
def recursion(n):
 
    print(n)
    recursion(n+1)
 
recursion(1)　
```

 出现的效果就是，这个函数在不断的调用自己，每次调用就n+1,相当于循环了。

 ![](/images/recursive/Recursive_1.png)


可是为何执行了900多次就出错了呢？还说超过了最大递归深度限制，为什么要限制呢？

通俗来讲，是因为每个函数在调用自己的时候 还没有退出，占内存，多了肯定会导致内存崩溃。

本质上讲呢，在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，
每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。


函数调用的栈结构：

![](/images/recursive/Recursive_stack.png)


## 递归的特点
让我们通过现象来看本质， 下面是是用递归写的，让10不断除以2，直到0为止。

![](/images/recursive/Recursive_2.png)
为何结果先打印了10、5、2、1，然后又打印了1、2、5、10呢？打印10、5、2、1你可以理解，
因为函数在一层层的调用自己嘛,但1、2、5、10是什么逻辑呢？ 因为当前函数在执行过程中又调用了自己一次，
当前这次函数还没结束，程序就又进了入第2层的函数调用，第2层没结束就又进入了第3层，只到n/2 > 0不成立时才停下来， 
此时问你，程序现在直接结束么？no,no,no, 现在递归已经走到了最里层，最里层的函数不需要继续递归了,会执行下面2句

![](/images/recursive/Recursive_4.png)

打印的是1， 然后最里层的函数就结束了，结束后会返回到之前调用它的位置。
即上一层，上一层打印的是2，再就是5，再就是10，即最外层函数，然后结束，总结，这个递归就是一层层进去，还要一层层出来。


 
![](/images/recursive/Recursive_5.png)

通过上面的例子，我们可以总结递归几个特点：

1. 必须有一个明确的结束条件，要不就会变成死循环了，最终撑爆系统

2. 每次进入更深一层递归时，问题规模相比上次递归都应有所减少

3. 递归执行效率不高，递归层次过多会导致栈溢出
 

## 递归有什么用呢？
可以用于解决很多算法问题，把复杂的问题分成一个个小问题，一一解决。

比如求斐波那契数列、汉诺塔、多级评论树、二分查找、求阶乘等。用递归求斐波那契数列、汉诺塔 对初学者来讲可能理解起来不太容易，所以我们用阶乘和二分查找来给大家演示一下。

 

### 求阶乘
任何大于1的自然数n阶乘表示方法： 
n!=1×2×3×……×n 
或 
n!=n×(n-1)!

 

即举例：4! = 4x3x2x1 = 24 

用递归代码来实现
```python

def factorial(n):
 
    if n == 0: #是0的时候，就运算完了
        return 1
    return n * factorial(n-1) # 每次递归相乘，n值都较之前小1
 
 
d = factorial(4)
print(d)
　
```

## 2分查找 
我们首先引入这样一个问题：如果规定某一科目成绩分数范围：[0,100]，现在小明知道自己的成绩，
他让你猜他的成绩，如果猜的高了或者低了都会告诉你，用最少的次数猜出他的成绩，你会如何设定方案？
（排除运气成分和你对小明平时成绩的了解程度）

①最笨的方法当然就是从0开始猜，一直猜到100分，考虑这样来猜的最少次数：1（运气嘎嘎好），100（运气嘎嘎背）；

②其实在我们根本不知道对方水平的条件下，我们每一次的猜测都想尽量将不需要猜的部分去除掉，而又对小明不了解，不知道其水平到底如何，那么我们考虑将分数均分，

将分数区间一分为2，我们第一次猜的分数将会是50，当回答是低了的时候，我们将其分数区域从【0,100】确定到【51,100】；
当回答高了的时候，我们将分数区域确定到【0,49】。这样一下子就减少了多余的50次猜想（从0数到49）（或者是从51到100）。

③那么我们假设当猜完50分之后答案是低了，那么我们需要在【51,100】分的区间内继续猜小明的分数，
同理，我们继续折半，第二次我们将猜75分，当回答是低了的时候，我们将其分数区域从【51,100】确定到【76,100】；
当回答高了的时候，我们将分数区域确定到【51,74】。这样一下子就减少了多余的猜想（从51数到74）（或者是从76到100）。

④就此继续下去，直到回复是正确为止，这样考虑显然是最优的


## 补充：
 在讲特性时，我们说递归效率不高，因为每递归一次，就多了一层栈，递归次数太多还会导致栈溢出，这也是为什么python会默认限制递归次数的原因。但有一种方式是可以实现递归过程中不产生多层栈的，即尾递归，
 
## 尾递归
 如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。
 
 当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。
 
 尾递归例子
 

```python
 def calc(n):
     print(n - 1)
     if n > -50:
         return calc(n-1)
```
 
 我们之前求的阶乘是尾递归么？
```python

 def factorial(n):
  
     if n == 0: #是0的时候，就运算完了
         return 1
     return n * factorial(n-1) # 每次递归相乘，n值都较之前小1
  
  
 d = factorial(4)
 print(d)
 
```
 上面的这种递归计算最终的return操作是乘法操作。所以不是尾递归。
 因为每个活跃期的返回值都依赖于用n乘以下一个活跃期的返回值，
 因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。