

## [原文](http://jennica.space/2016/11/30/acm-challenge-hard/)

# 算法梳理：高级篇



### 高级篇

1. 数论（二）

2. 博弈论

3. 图论（二）

4. 常用技巧（二）

5. 智慧搜索

6. 分治

7. 字符串


## 2.1 数论（二）

### 2.1.1 核心思想

1. 线性方程组：可以采用高斯消元法求解。将方程组用矩阵表示后，遍历每列，
保留该列系数最大的行（列主元高斯消元，减少误差），并将其乘以一定倍数用于消除其他行的该列元素。

2. 一次同余方程：ax=b (mod m)。定义a的逆元为y满足ay=1 (mod m)，则x=yb(mod m)。逆元y可以用扩展欧几里得求解。

3. 费马小定律：若p为素数，a与p互素，则有a^(p-1)=1 (mod p)。

4. 欧拉定理：对于一个正整数N的素数幂分解N=P1^q1P2^q2…Pn^qn，欧拉函数φ(N)=N(1-1/P1)(1-1/P2)…*(1-1/Pn)，
意义是不大于N且与N互素的正数个数。此时，对于与N互素的x，有x^φ(N)=1 (mod N)。费马小定律可以看作欧拉定理的推广。

5. 线性同余方程组：若有解则一定有无数解，解的全集可写作x=b (mod m)。初始化为x=0，m=1。
逐次加入一个新的方程ax=b (mod m)，将上一步的x用mt+b的形式代入，转化为一次同余方程。

6. 中国剩余定理：n=ab（a、b互素），则（x mod n）等价于（x mod a，x mod b）。
所以，通过对n的质因数分解，可以通过只考虑模n的素因子的幂p^k来计算。

7. n!模p：将阶乘表示为n!=ap^e，则e=n/p+n/p^2+n/p^3+…。
由于阶乘中不能被p整除的项呈现周期性，乘积为(p-1)!^(n/p)*(n mod p)!。
根据威尔逊定理，(p-1)!=-1(mod p)。考虑可以被p整除的部分，通过全部除以p，可以递归到n/p的范围考虑。

8. 组合数模p：将n和m用p进制法表示后，根据Lucas定理，Lucas(n,m,p)=c(n%p,m%p)*Lucas(n/p,m/p,p) ，
则对于每一位，计算其组合数模p，将答案相乘即为C(n, m)模p。

9. 容斥原理：先不考虑重叠的情况，将所有对象计算出来，再不断递归把重复计算的数目排斥出去，
直到结果既无遗漏又无重复。由于递归时排斥采取减法，从全局来看应根据地柜深度的奇偶性判断符号正负。

10. 莫比乌斯函数：在容斥定理中，每次排斥的规模d如果是n的约数，则被加减多次的总和只和n/d有关。
求这个系数的函数叫莫比乌斯函数，记作µ(n/d)。若x可以被大于1的完全平方数整除，
则µ(x)=0；否则计算x的质因子个数k，µ(x)=(-1)^k。莫比乌斯反演定理利用µ(x)推出，f(n)=∑g(d)等价于g(d)=∑µ(n/d)*f(d)。

11. Polya计数定理：在组合问题中，有时要求把旋转和翻转之后的状态看作相同态，计算本质不同的个数。
此时应把所有方案重复计算相同次数，再把结果除以重复的次数。另外，立方体的染色、相同颜色的数量限制、相邻状态限制，都可以用Polya求解。

## 2.2 博弈论

### 2.2.1 核心思想

1. 必胜策略：任意方式都无法转移到必胜态的为必败态N，存在一种方式可以转移到必败态的为必胜态P。

2. Nim：初始有n堆石子，每堆有ai石子，游戏规则是每次从某堆中取走至少一颗，判断初始状态是否必胜。
若ai数组异或结果非0则为必胜态，否则为必败态。

3. Grundy数：当前状态的Grundy值是除任意一步所能转移到的状态的Grundy值以外的最小非负整数。
所以，从Grundy为x出发，可以转移到Grundy为0到x-1的状态。Grundy数等价于Nim中的石子个数，再通过异或判断状态必胜与否。

### 2.2.2 优化细节

1. 取放石子：Grundy数可以转移到更大值，等价于Nim中放回石子。
但可以通过采取对应策略再转移到原值的状态，所以对胜负没有影响。
但此时，状态可能出现循环，所以需要注意可能会出现不分胜负、达成平局、永不结束的情况。

2. 复合游戏：由于在Nim中，只要异或值相同，石子堆数不影响局面性质。
所以对分割后的各部分取异或，就可以用一个Grundy数来表示几个游戏复合而成的状态。

## 2.3 图论（二）

### 2.3.1 核心思想

1. 强连通分量：图中任意两点可互达的子图叫做强连通分量。任意有向图都可以分解为若干个不相交的强连通分量。
将图中的强连通分量都缩成一个顶点，可以将原图转化为DAG（有项无环图）。

2. 强连通分量分解：通过两次DFS实现。第一次DFS时，回溯时为顶点标号（后序遍历）。
标号越小表示离图尾越近，即搜索树的叶子。第二次DFS时，将所有边反向后，从标号大的顶点开始遍历，
每次遍历的顶点集合组成一个强连通分量，记录该分量的拓扑序。
接着，再取未访问节点中最大标号的顶点开始DFS，拓扑序加一。直到顶点全部遍历，算法结束。总的复杂度是O(V+E)。

3. 2-SAT：对于每个子句中文字个数不超过二的合取范式，可以将每个子句等价转化为两个蕴含关系，
将所有蕴含关系为边、每个变量取真取假为点，构建有向图。
图中的每个强连通分量内，若某个点为正确，则分量中所有顶点都为真。对于每个布尔变量，考虑其取真取假的两个点，
点所在的强连通分量拓扑序大的点情况为真。由此，得到一组合法的布尔变量赋值。

4. LCA（最近公共祖先）：有根树中，两个结点的公共祖先中距离最近的那个成为LCA。
高效求解LCA可以采用倍增法预处理加二分搜索，或中序遍历后利用线段树或BIT做RMQ求解。

## 2.4 常用技巧（二）

### 2.4.1 核心思想

1. 栈的应用：在栈内维护一个下标和对应值都单向递增的序列，则可求距离自己最近的比自己大的值。

2. 双向队列的应用：队列中维护一个以某区间内最小值开始，单向递增的序列，则可求窗口大小一定的滑动最小值。

3. 倍增法：通过预处理，计算出距离每个点2的次幂处的状态。
由于转移到的目的地满足一定条件，且具有与下标单向相关性，所以可以通过二分搜索，每次将2的幂减1，判断是否出终极目标的位置。

### 2.4.2 优化细节

1. 数量的二进制表示：在一定数量的物品中挑选若干个，可以通过每次是否添加2的次幂个物品来决定最终结果。
将原本枚举的复杂度O(n)降至二进制位数O(logn)。

2. 连续状态转移：在DP中，如果某状态可由连续的下标的一些状态转移来，并要求其最值。
可以试着把状态转移方程分为两部分，一部分为常量，另一部分为只与前一状态下标有关。
则问题转化为，求某个函数在某个滑动窗口内的最值。如果窗口大小固定不变，则可利用双向队列求解滑动最值。

## 2.5 智慧搜索

### 2.5.1 核心思想

1. 剪枝：调整搜索顺序，从分支少或影响大的部分开始搜索。无任何效用或无法到达最终态的步骤可以提前剪枝。
没有最优解则剪枝，通常可以通过贪心等算法求得最优解下界的下界。

2. IDA：通过搜索判断是否有某个不超过x的解，将x从0开始每次加1，首次求到解的x就是最优解。
这样，在搜索过程中，就不会访问比最优解更大的状态。
迭代加深搜索（IDDFS）类似于宽度有限搜索，按距离初始状态的远近访问各个状态，而IDA会通过估算下届提前剪枝优化。

3. A*：BFS和Dijkstra利用下界优化，将优先队列中的键值改为初始状态到当前状态的距离加上到目标状态的距离下界。
此时，优先队列顶端元素未必是初始状态到当前状态的最短路。

### 2.5.2 优化细节

1. IDA与A对比：

2. IDA针对DFS，A针对BFS。

3. IDA不怎么花费内存，A需要关于搜索空间的线性的内存。

4. 通过不同路径到达同一状态，IDA效率急剧下降，而A可以通过选取合适的下届保证每个状态至多检查一次。

5. IDA*在不断增加递归深度限制时重复搜索了很多状态，但总的访问状态数和最后一次访问状态数是同一数量级的。

## 2.6 分治

### 2.6.1 核心思想

1. 分治：将问题划分为更小规模的子问题，递归解决子问题，再将结果合并从而高效解决问题。

2. 数列上的分治：每次递归数列长度减半，合并时除将子问题的情况合并外，还需要考虑左右两个子数列交互问题。
通常需要在递归时，维护数列状态，如排序或某些统计值大小。

3. 树上的分治：树的重心是指删除该顶点后最大子树顶点数最小的点。通过树的重心来分解树，可以避免分解不均匀导致的退化现象。
按重心分割，可以保证，每次划分后子树的大小都不超过n/2，所以递归深度不超过O(logn)。

4. 平面上的分治：将待求解平面按x或y坐标分为两部分，各子问题递归求解，再合并。
对于两子平面交互的部分，通常可以通过一些限制条件，只考虑有可能达到最优解的一些状态，可以极大降低复杂度。

### 2.6.2 优化细节

1. 树的递归：递归分解无根树时，可以代入两个参数，当前节点及父节点。
在更新当前节点时，其所有相连顶点中，除去父节点及已被分解出去的子树根节点，其余就是可以继续递归的子节点。

## 2.7 字符串

### 2.7.1 核心思想

1. KMP：通过DP计算next数组，next[i]表示以模式串的第i个字符结尾的后缀与模式串前缀的最长公共子串中，公共子串结尾的位置。
当模式串与母串进行匹配时，若发生字符不匹配的情况，可以将母串指针位置保持不变，将模式串的指针前移至next位置的后一个字符，
若依然不等，递归next直到相等或者超出模式串头。复杂度O(m+n)。

2. Trie：树上的边对应字符，从根到节点的路径上的字符序列即为该节点表示的字符串。
Trie是一个高效维护字符串集合的数据结构，查找长度为l的字符串复杂度为O(l)，同时节约空间。

3. AC自动机：又叫Aho-Corasick算法，将多个模式串的所有前缀用Trie表示，再在Trie上进行KMP。

4. Robin-Carp哈希：将字符串看作b进制数，循环移动头尾，可以得到每个串的哈希结果，用来判断两字符串是否匹配。可推广到二维情况的哈希算法。

5. 后缀数组（SA）：将字符串的所有后缀按字典序排列后得到的数组，sa[i]表示排名第i的后缀的起始位置，rank[i]表示其实位置为i的后缀的排名。
利用倍增的思想，可以在log(n(logn)^2)时间内得到后缀数组。
通过计算得到的长度为k的所有后缀及其排名，利用rank[i]和rank[i+2]组合得到长度为2k的后缀及排名。

6. 高度数组（LCP）：后缀数组中两个相邻后缀的最长公共前缀。由于h[i-1]≥h[i]-1，可以从左到右遍历后缀头的位置，通过尺取法，在O(n)时间内求得。
由于高度数组的传递性，结合RMQ，可以求得任意两个后缀间的最长前缀。

### 2.7.2 经典模型

1. 串的状态转移：KMP／AC自动机

2. 单字符串匹配：KMP／Robin-Carp哈希

3. 多字符串匹配：Robin-Carp哈希／AC自动机／SA+二分搜索／扩展KMP

4. 最长公共子串：strcat+SA+LCP+RMQ

5. 最长回文子串：strcat+SA+LCP+RMQ／Manacher